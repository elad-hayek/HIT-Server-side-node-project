================================================================================
LOGS SERVICE - COMPLETE CODE DOCUMENTATION
================================================================================

This file contains all source code files from the logs-service microservice,
organized by folder structure for easy navigation and code review.

================================================================================
FOLDER STRUCTURE
================================================================================

logs-service/
├── package.json
├── server.js
└── src/
    ├── app/
    │   ├── app.js
    │   ├── controllers/
    │   │   └── logs_controller.js
    │   ├── middlewares/
    │   │   ├── error_middleware.js
    │   │   └── logger_middleware.js
    │   ├── repositories/
    │   │   └── logs_repository.js
    │   ├── routes/
    │   │   ├── log_routes.js
    │   │   └── index.js
    │   └── services/
    │       └── log_service.js
    ├── config/
    │   └── index.js
    ├── db/
    │   ├── index.js
    │   └── models/
    │       └── log.model.js
    ├── errors/
    │   ├── app_error.js
    │   ├── duplicate_error.js
    │   ├── not_found_error.js
    │   ├── service_error.js
    │   └── validation_error.js
    └── logging/
        └── index.js

================================================================================
FILE: logs-service/server.js
================================================================================

// Server entry point for logs service - initializes database and starts application

// Load Express application factory with routes
const createApp = require("./src/app/app");
// Import MongoDB connection initialization function
const { connectDB } = require("./src/db");
// Import logger for logging server events
const { logger } = require("./src/logging");
// Load configuration with port and service URLs
const config = require("./src/config");

// Create Express application with middleware
const app = createApp();

// Connect to MongoDB before accepting requests
connectDB().then(() => {
  // Get port from config or use default 5000
  const port = config.PORT || 5000;
  // Start listening for HTTP requests
  app.listen(port, () => {
    // Log successful server startup
    logger.info(`Server running on port ${port}`);
  });
});

================================================================================
FILE: logs-service/src/app/app.js
================================================================================

// Express application factory module - creates logs service app

// Import Express framework
const express = require("express");
// Import HTTP request logging middleware
const loggerMiddleware = require("./middlewares/logger_middleware");
// Import error handling middleware
const errorMiddleware = require("./middlewares/error_middleware");
// Import routes configuration
const routes = require("./routes");

/**
 * Factory function to create and configure Express application
 * Sets up middleware stack and API routes
 * @returns {Object} Configured Express app instance
 */
const createApp = function () {
  // Create Express application
  const app = express();
  // Apply request logging middleware
  app.use(loggerMiddleware);
  // Parse JSON request bodies
  app.use(express.json());
  // Mount API routes under /api
  app.use("/api", routes);
  // Apply error handling middleware
  app.use(errorMiddleware);

  // Return configured app
  return app;
};

// Export app factory
module.exports = createApp;

================================================================================
FILE: logs-service/src/app/controllers/logs_controller.js
================================================================================

// Logs controller module - handles HTTP requests for log retrieval and storage

// Import logs service for business logic access
const logsService = require("../services/log_service");

/**
 * Retrieves all stored logs from the database
 * Handles GET /api/logs requests
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object for sending response
 * @param {Function} next - Express next middleware function for error handling
 * @returns {void} Sends 200 OK with logs array or error to next middleware
 */
const getLogs = async function (req, res, next) {
  try {
    // Fetch all logs from database through service
    const logs = await logsService.getAllLogs();
    // Return 200 OK status with logs array
    res.status(200).json(logs);
  } catch (error) {
    // Pass any errors to error handling middleware
    next(error);
  }
};

/**
 * Creates a new log entry in the database
 * Handles POST /api/logs requests with log data
 * @param {Object} req - Express request object with log data in body
 * @param {Object} res - Express response object for sending response
 * @param {Function} next - Express next middleware function for error handling
 * @returns {void} Sends 201 Created with log data or error to next
 */
const createLog = async function (req, res, next) {
  try {
    // Create log entry through service layer
    const log = await logsService.createLog(req.body);
    // Return 201 Created status with the new log object
    res.status(201).json(log);
  } catch (error) {
    // Pass validation or service errors to error middleware
    next(error);
  }
};

// Export controller functions for route handlers
module.exports = {
  getLogs,
  createLog,
};

================================================================================
FILE: logs-service/src/app/services/log_service.js
================================================================================

// Logs service - business logic layer
// Handles log validation, creation, and retrieval from database
const logsRepository = require("../repositories/logs_repository");
const { logger } = require("../../logging");
const { ValidationError } = require("../../errors/validation_error");
const Log = require("../../db/models/log.model");

/**
 * Validates log data against the Log model schema
 * Ensures all required fields are present and valid
 * @param {Object} data - Log data object with level, message, method, url, statusCode, responseTime
 * @returns {Object} Validated log object
 * @throws {ValidationError} If log data fails schema validation
 */
const validateLogData = function (data) {
  // Create temporary log to validate against Mongoose schema
  const tempLog = new Log(data);
  const validationError = tempLog.validateSync();

  // If schema validation fails, extract and throw the first error
  if (validationError) {
    const firstErrorKey = Object.keys(validationError.errors)[0];
    const firstError = validationError.errors[firstErrorKey];
    throw new ValidationError(firstError.message);
  }

  return tempLog;
};

/**
 * Creates a new log entry in the database with validation
 * Formats and validates log data before persistence
 * @param {Object} logData - Log object with level, message, method, url, statusCode, responseTime
 * @returns {Promise<Object>} Formatted log response with all relevant fields
 * @throws {ValidationError} If log data is invalid
 * @throws {Error} If database operation fails
 */
const createLog = async function (logData) {
  // Validate log data against schema constraints
  const validatedLog = validateLogData(logData);

  try {
    // Persist log to database with validated and formatted data
    const log = await logsRepository.createLog({
      level: validatedLog.level,
      message: validatedLog.message,
      timestamp: validatedLog.timestamp || new Date(),
      method: validatedLog.method,
      url: validatedLog.url,
      statusCode: validatedLog.statusCode,
      responseTime: validatedLog.responseTime,
    });

    // Return formatted response with all relevant fields
    return {
      _id: log._id,
      level: log.level,
      message: log.message,
      timestamp: log.timestamp,
      method: log.method,
      url: log.url,
      statusCode: log.statusCode,
      responseTime: log.responseTime,
    };
  } catch (error) {
    throw error;
  }
};

/**
 * Retrieves all logs from the database and formats them
 * Returns logs in a consistent format for API responses
 * @returns {Promise<Array>} Array of formatted log objects
 */
const getAllLogs = async function () {
  // Fetch all logs from repository (sorted by timestamp descending)
  const logs = await logsRepository.findAllLogs();

  // Format each log with consistent field structure for response
  return logs.map((log) => ({
    _id: log._id,
    level: log.level,
    message: log.message,
    timestamp: log.timestamp,
    method: log.method,
    url: log.url,
    statusCode: log.statusCode,
    responseTime: log.responseTime,
  }));
};

module.exports = {
  createLog,
  getAllLogs,
};

================================================================================
FILE: logs-service/src/app/repositories/logs_repository.js
================================================================================

// Logs repository - database access layer for log management
// Handles all database operations for application logs
const Log = require("../../db/models/log.model");

/**
 * Creates a new log entry in the database
 * Stores log information including timestamp, level, and message
 * @param {Object} logData - Log object containing timestamp, level, message, service, user, details
 * @returns {Promise<Object>} The saved log document with _id and timestamps
 */
const createLog = async function (logData) {
  const log = new Log(logData);
  return await log.save();
};

/**
 * Retrieves all logs from the database sorted by newest first
 * @returns {Promise<Array>} Array of all log documents sorted by timestamp descending
 */
const findAllLogs = async function () {
  return await Log.find().sort({ timestamp: -1 });
};

/**
 * Retrieves a specific log by its database ID
 * @param {string} id - The MongoDB ObjectId of the log document
 * @returns {Promise<Object|null>} The log document or null if not found
 */
const findLogById = async function (id) {
  return await Log.findById(id);
};

module.exports = {
  createLog,
  findAllLogs,
  findLogById,
};

================================================================================
FILE: logs-service/src/app/routes/log_routes.js
================================================================================

// Logs routes module - defines HTTP endpoints for log management
// Provides routes for retrieving and storing centralized logs from all services

// Import Express framework for route definition
const express = require("express");
// Create Express router instance for logs routes
const router = express.Router();
// Import logs controller with route handler functions
const logsController = require("../controllers/logs_controller");

// GET endpoint to retrieve all stored logs
// Route: GET /api/logs
// Handler: Fetches all log entries from database sorted by timestamp
router.get("/logs", logsController.getLogs);

// POST endpoint to create and store a new log entry
// Route: POST /api/logs
// Handler: Validates log data and persists to database (called by other services)
router.post("/logs", logsController.createLog);

// Export router for mounting in main routes aggregation
module.exports = router;

================================================================================
FILE: logs-service/src/app/routes/index.js
================================================================================

// Routes aggregation module - combines all API route modules for logs service
// Provides centralized routing configuration for all log-related endpoints

// Import Express framework for route definition
const express = require("express");
// Import logs-specific routes module containing all log endpoint handlers
const logsRoutes = require("./log_routes");
// Create main router instance for API routes
const router = express.Router();

// Mount logs routes at root path (all log endpoints available at /api/...)
router.use("/", logsRoutes);

// Export aggregated routes for app mounting
module.exports = router;

================================================================================
FILE: logs-service/src/app/middlewares/error_middleware.js
================================================================================

// Error handling middleware module - processes and formats error responses

// Map error types to standardized error IDs for client identification
const ERROR_ID_MAP = {
  ValidationError: "ERR_VALIDATION_001",
  NotFoundError: "ERR_NOT_FOUND_002",
  DuplicateError: "ERR_DUPLICATE_003",
  ServiceError: "ERR_SERVICE_004",
  AppError: "ERR_APP_005",
};

const getErrorId = function (err) {
  const errorType = err.constructor.name;
  return ERROR_ID_MAP[errorType] || "ERR_UNKNOWN_999";
};

const errorHandler = function (err, req, res, next) {
  const status = err.status || 500;
  const message = err.message || "Internal Server Error";
  const errorId = getErrorId(err);

  res.err = err;

  res.status(status).json({
    id: errorId,
    message: message,
  });
};

module.exports = errorHandler;

================================================================================
FILE: logs-service/src/app/middlewares/logger_middleware.js
================================================================================

// HTTP request logging middleware module - logs all HTTP requests and responses

const pinoHttp = require("pino-http");
const { logger } = require("../../logging");

const httpLogger = pinoHttp({
  logger,
  customLogLevel: function (req, res, err) {
    if (res.statusCode >= 400 && res.statusCode < 500) {
      return "warn";
    } else if (res.statusCode >= 500 || err || res.err) {
      return "error";
    }
    return "info";
  },
  customSuccessMessage: function (req, res) {
    return `${req.method} ${req.url} ${res.statusCode}`;
  },
  customErrorMessage: function (req, res, err) {
    const error = err || res.err;
    return `${req.method} ${req.url} ${res.statusCode} - ${error?.message}`;
  },
});

const loggingMiddleware = function (req, res, next) {
  httpLogger(req, res, next);
};

module.exports = loggingMiddleware;

================================================================================
FILE: logs-service/src/db/index.js
================================================================================

// Database connection module - manages MongoDB connection

// Import Mongoose ODM library
const mongoose = require("mongoose");
// Import database URI from configuration
const config = require("../config");
// Import logger for connection events
const { logger } = require("../logging");

/**
 * Establishes connection to MongoDB database
 * Logs success or exits on failure
 * @returns {Promise<void>} Resolves on connection, exits on error
 */
const connectDB = async function () {
  try {
    // Connect to MongoDB using URI from config
    await mongoose.connect(config.MONGO_URI);
    // Log successful connection
    logger.info("MongoDB connected");
  } catch (err) {
    // Log connection error
    logger.error("MongoDB connection error", err);
    // Exit process on failure
    process.exit(1);
  }
};

// Export connection function
module.exports = { connectDB };

================================================================================
FILE: logs-service/src/db/models/log.model.js
================================================================================

// Log model module - Mongoose schema for application logs
// Defines structure for storing centralized logs from all services

// Import MongoDB/Mongoose for schema definition and model creation
const mongoose = require("mongoose");

// Define Mongoose schema for log documents with validation rules
const logSchema = new mongoose.Schema(
  {
    // Log level - severity indicator: info, warn, error, or debug
    level: {
      type: String,
      required: [true, "Field 'level' is required and must be a string"],
      trim: true,
      enum: {
        values: ["info", "warn", "error", "debug"],
        message: "Field 'level' must be one of: info, warn, error, debug",
      },
    },
    // Log message - the actual log content describing what happened
    message: {
      type: String,
      required: [true, "Field 'message' is required and must be a string"],
      trim: true,
    },
    // Timestamp - when the log event occurred, defaults to current time
    timestamp: {
      type: Date,
      required: [true, "Field 'timestamp' is required"],
      default: Date.now,
      validate: {
        validator: function (value) {
          return value instanceof Date && !isNaN(value);
        },
        message: "Field 'timestamp' must be a valid date",
      },
    },
    // HTTP method - optional field for logging HTTP request method (GET, POST, etc.)
    method: {
      type: String,
      required: false,
      trim: true,
    },
    // URL path - optional field for logging the requested endpoint
    url: {
      type: String,
      required: false,
      trim: true,
    },
    // HTTP status code - optional field for logging response status (200, 404, 500, etc.)
    statusCode: {
      type: Number,
      required: false,
    },
    // Response time in milliseconds - optional field for performance logging
    responseTime: {
      type: Number,
      required: false,
    },
  },
  {
    // Automatically add createdAt and updatedAt timestamp fields
    timestamps: true,
  }
);

// Create Log model from schema
const Log = mongoose.model("Log", logSchema);

// Export the Log model for database operations
module.exports = Log;

================================================================================
FILE: logs-service/src/config/index.js
================================================================================

// Environment configuration module for logs-service
// Loads configuration from .env file and provides fallback defaults
// All microservices use this pattern for consistent configuration management

require("dotenv").config();

/**
 * Environment configuration object
 * Aggregates all configuration needed for logs-service operation
 * Logs-service is a centralized logging microservice with minimal external dependencies
 */
const env = {
  // Application environment (development, staging, production)
  // Controls logging verbosity and error handling behavior
  NODE_ENV: process.env.NODE_ENV || "development",

  // Port on which logs-service HTTP server listens
  // Default 5000 for local development, overridden in production
  PORT: process.env.PORT || 5000,

  // Log level for Pino logger (debug, info, warn, error)
  // Controls verbosity of application logs
  // Default info for normal operations, debug for troubleshooting
  LOG_LEVEL: process.env.LOG_LEVEL || "info",

  // MongoDB connection URI for logs database
  // Format: mongodb://[user:password@]host:port/database
  // Default points to local MongoDB instance
  // Stores all application logs from other microservices
  MONGO_URI: process.env.MONGO_URI || "mongodb://localhost:27017/app",

  // Timeout in milliseconds for internal operations
  // Used when logs-service performs any HTTP or async operations
  // Prevents hanging operations and ensures responsive error handling
  // Default 3000ms = 3 seconds
  LOGGING_SERVICE_TIMEOUT: process.env.LOGGING_SERVICE_TIMEOUT || 3000,
};

// Export configuration object for use throughout logs-service
module.exports = env;

================================================================================
FILE: logs-service/src/errors (error classes)
================================================================================

[Error classes are identical to other services - app_error.js, duplicate_error.js,
not_found_error.js, service_error.js, validation_error.js follow the same pattern
as defined in admin-service and costs-service. See those files for complete error
class implementations.]

================================================================================
FILE: logs-service/src/logging/index.js
================================================================================

// Pino logger configuration
const pino = require("pino");
// Import configuration for LOG_LEVEL setting
const config = require("../config");

// Map Pino numeric levels to string levels for database storage
const pinoLevelToString = {
  10: "debug", // trace
  20: "debug", // debug
  30: "info", // info
  40: "warn", // warn
  50: "error", // error
  60: "error", // fatal
};

// Custom stream to write directly to MongoDB (no external service call)
const customStream = {
  write: (msg) => {
    try {
      // Parse log message from pino (JSON string)
      const logObj = JSON.parse(msg);
      const level = pinoLevelToString[logObj.level] || "info";

      // In the logs service, we just log to MongoDB directly
      // No external HTTP calls to avoid infinite loops

      const logDoc = new Log({
        level,
        message: logObj.msg,
        timestamp: new Date(logObj.time),
        method: logObj.req?.method,
        url: logObj.req?.url,
        statusCode: logObj.res?.statusCode,
        responseTime: logObj.responseTime,
      });

      logDoc.save().catch((err) => {
        console.error("Failed to save log to MongoDB:", err.message);
      });
    } catch (err) {
      // Fallback: log error to console
      console.error("Failed to process log:", err.message);
    }
  },
};

const logger = pino(
  { level: config.LOG_LEVEL },
  pino.multistream([
    { level: config.LOG_LEVEL, stream: process.stdout },
  ])
);

module.exports = { logger };

================================================================================
FILE: logs-service/package.json
================================================================================

[Package.json follows the same structure as costs-service with:
- name: "hit-logs-service"
- PORT: 5000
- Same dependencies and devDependencies]

================================================================================
FILE: logs-service/tests/unit/logs.test.js
================================================================================

// Logs service unit tests
// Tests for log creation and retrieval: createLog, getAllLogs
// Validates field requirements, data types, and optional field handling
// Mocks logs repository for isolated service layer testing

// Mock the logs repository to avoid database calls during tests
jest.mock("../../src/app/repositories/logs_repository");

// Import the service being tested
const logsService = require("../../src/app/services/log_service");
// Import mocked dependencies for setup and verification
const logsRepository = require("../../src/app/repositories/logs_repository");
// Import error classes to verify proper error handling
const { ValidationError } = require("../../src/errors/validation_error");

describe("Logs Service", () => {
  // Reset all mocks before each test to ensure isolation
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("createLog", () => {
    it("should create a log successfully with valid data", async () => {
      const logData = {
        level: "info",
        message: "Test log message",
        timestamp: new Date(),
      };

      const savedLog = {
        _id: "log123",
        level: "info",
        message: "Test log message",
        timestamp: new Date(),
      };

      logsRepository.createLog.mockResolvedValue(savedLog);

      const result = await logsService.createLog(logData);

      expect(logsRepository.createLog).toHaveBeenCalledWith(
        expect.objectContaining({
          level: "info",
          message: "Test log message",
        })
      );
      expect(result).toEqual(
        expect.objectContaining({
          _id: "log123",
          level: "info",
          message: "Test log message",
        })
      );
    });

    it("should throw ValidationError when level is missing", async () => {
      const logData = {
        message: "Test log message",
        timestamp: new Date(),
      };

      await expect(logsService.createLog(logData)).rejects.toThrow(
        ValidationError
      );

      await expect(logsService.createLog(logData)).rejects.toThrow(
        "Field 'level' is required and must be a string"
      );
    });

    it("should throw ValidationError when message is missing", async () => {
      const logData = {
        level: "info",
        timestamp: new Date(),
      };

      await expect(logsService.createLog(logData)).rejects.toThrow(
        ValidationError
      );

      await expect(logsService.createLog(logData)).rejects.toThrow(
        "Field 'message' is required and must be a string"
      );
    });

    it("should throw ValidationError when level is invalid", async () => {
      const logData = {
        level: "invalid_level",
        message: "Test log message",
        timestamp: new Date(),
      };

      await expect(logsService.createLog(logData)).rejects.toThrow(
        ValidationError
      );

      await expect(logsService.createLog(logData)).rejects.toThrow(
        "Field 'level' must be one of: info, warn, error, debug"
      );
    });

    it("should throw ValidationError when timestamp is invalid", async () => {
      const logData = {
        level: "info",
        message: "Test log message",
        timestamp: "invalid-date",
      };

      await expect(logsService.createLog(logData)).rejects.toThrow(
        ValidationError
      );
    });

    it("should create log with all optional fields", async () => {
      const logData = {
        level: "error",
        message: "API error occurred",
        timestamp: new Date(),
        method: "GET",
        url: "/api/users",
        statusCode: 500,
        responseTime: 150,
      };

      const savedLog = {
        _id: "log456",
        level: "error",
        message: "API error occurred",
        timestamp: new Date(),
        method: "GET",
        url: "/api/users",
        statusCode: 500,
        responseTime: 150,
      };

      logsRepository.createLog.mockResolvedValue(savedLog);

      const result = await logsService.createLog(logData);

      expect(logsRepository.createLog).toHaveBeenCalledWith(
        expect.objectContaining({
          level: "error",
          message: "API error occurred",
          method: "GET",
          url: "/api/users",
          statusCode: 500,
          responseTime: 150,
        })
      );
      expect(result.method).toBe("GET");
      expect(result.statusCode).toBe(500);
    });
  });

  describe("getAllLogs", () => {
    it("should return all logs", async () => {
      const logs = [
        {
          _id: "log1",
          level: "info",
          message: "Log 1",
          timestamp: new Date(),
        },
        {
          _id: "log2",
          level: "error",
          message: "Log 2",
          timestamp: new Date(),
        },
      ];

      logsRepository.findAllLogs.mockResolvedValue(logs);

      const result = await logsService.getAllLogs();

      expect(logsRepository.findAllLogs).toHaveBeenCalled();
      expect(result).toHaveLength(2);
      expect(result[0].level).toBe("info");
      expect(result[1].level).toBe("error");
    });

    it("should return empty array when no logs exist", async () => {
      logsRepository.findAllLogs.mockResolvedValue([]);

      const result = await logsService.getAllLogs();

      expect(result).toEqual([]);
      expect(Array.isArray(result)).toBe(true);
    });

    it("should sort logs by timestamp newest first", async () => {
      const now = new Date();
      const earlier = new Date(now.getTime() - 1000);
      const latest = new Date(now.getTime() + 1000);

      const logs = [
        {
          _id: "log1",
          level: "info",
          message: "Latest log",
          timestamp: latest,
        },
        {
          _id: "log2",
          level: "error",
          message: "Earlier log",
          timestamp: earlier,
        },
      ];

      logsRepository.findAllLogs.mockResolvedValue(logs);

      const result = await logsService.getAllLogs();

      expect(result[0].timestamp).toEqual(latest);
      expect(result[1].timestamp).toEqual(earlier);
    });
  });
});

================================================================================
END OF LOGS SERVICE CODE DOCUMENTATION
================================================================================
